
! 
! this file is processed by ../java_tools/config_definition.jar tool
! comments start with '!'
!
!
! 
! First part is engine_configuration_s area, followed by a few tuning tables
!
! The only difference her is that engine_configuration_s area does not support hot modification while tuning tables could
! be modified without burning changes
!
!
! See also ../tunerstudio/readme.txt
!
! Q: How to add new fields?
! A: Find an 'unused' bit or unused int (usually the huge unusedEnd[] array at the end
!    rename the bit or substitute unused integer with any new fields of the same size
!    invoke gen_config.bat to apply the tools which would generate .h and .ini files
!
!
! each field is declared as
! type name;comment


#define TS_SIGNATURE "MS Ext"



! [IMPORTANT] every time TS_OUTPUT_SIZE is changed make sure to increment TS_SIGNATURE above
!
#define TS_OUTPUT_SIZE 288
#define TS_CONFIG_SIZE 11000
!
! this is used to confirm that firmware and TunerStudio are using the same rusefi.ini version
! so not forget to change fileVersion in rusefi.ini
! todo: is this not needed in light of TS_SIGNATURE?
#define TS_FILE_VERSION 20200310


#define FLASH_DATA_VERSION 10001
! all the sub-structures are going to be nested within the primary structure, that's
! needed to get a proper TunerStudio file

struct persistent_config_s 

struct_no_prefix engine_configuration_s

#define BLOCKING_FACTOR 256


#define CAM_INPUTS_COUNT 4

#define CONSOLE_DATA_PROTOCOL_TAG " @"

#define ETB_BIAS_CURVE_LENGTH 6

#define TRIGGER_TYPE_60_2 8
#define TRIGGER_TYPE_36_1 9

#define TOOTH_PACKET_COUNT 1000
#define TOOTH_PACKET_SIZE 2
#define TOOTH_DATA_LENGTH @@TOOTH_PACKET_SIZE@@*@@TOOTH_PACKET_COUNT@@

#define COMPOSITE_PACKET_COUNT 500
#define COMPOSITE_PACKET_SIZE 5
#define COMPOSITE_DATA_LENGTH @@COMPOSITE_PACKET_SIZE@@*@@COMPOSITE_PACKET_COUNT@@

#define IAC_PID_MULT_SIZE 8

#define NARROW_BAND_WIDE_BAND_CONVERSION_SIZE 8

#define CLT_CURVE_SIZE 16
#define CRANKING_CLT_IDLE_CURVE_SIZE 8
#define CLT_CRANKING_CURVE_SIZE 8
#define IDLE_ADVANCE_CURVE_SIZE 8
#define CRANKING_ADVANCE_CURVE_SIZE 4

#define CLT_TIMING_CURVE_SIZE 8
#define IDLE_VE_CURVE_SIZE 8

#define ETB_COUNT 2

#define IAT_CURVE_SIZE 16

#define VBAT_INJECTOR_CURVE_SIZE 8

#define DWELL_CURVE_SIZE 8

#define CRANKING_CURVE_SIZE 8

#define IGN_LOAD_COUNT 16
#define IGN_TPS_COUNT 16
#define IGN_RPM_COUNT 16

#define INJECTION_PIN_COUNT 12
#define IGNITION_PIN_COUNT 12

#define HW_MAX_ADC_INDEX 17

#define TRIGGER_INPUT_PIN_COUNT 3

#define FUEL_RPM_COUNT 16
#define FUEL_LOAD_COUNT 16

#define BOOST_RPM_COUNT 8
#define BOOST_LOAD_COUNT 8
#define VVT_RPM_COUNT 8
#define VVT_LOAD_COUNT 8

#define PEDAL_TO_TPS_SIZE 8

#define STFT_CELL_COUNT 4

#define CAN_DEFAULT_BASE 0x200


#define RPM_1_BYTE_PACKING_MULT 50
#define VOLTAGE_1_BYTE_PACKING_DIV 0.02

! These are used currently only for output channels - but could be for config as well
#define PACK_MULT_PRESSURE 30
#define PACK_MULT_PERCENT 100
#define PACK_MULT_TEMPERATURE 100
#define PACK_ADD_TEMPERATURE 40
#define PACK_MULT_MS 300
#define PACK_MULT_AFR 1000
#define PACK_MULT_ANGLE 50
#define PACK_MULT_VOLTAGE 1000
#define PACK_MULT_MASS_FLOW 10
#define TPS_1_BYTE_PACKING_MULT 2
#define LOAD_1_BYTE_PACKING_MULT 2
#define PACK_MULT_AFR_CFG 10
#define FSIO_TABLE_8 8

#define TPS_TPS_ACCEL_TABLE 8
#define MAP_ACCEL_TAPER 8
#define ADC_CHANNEL_NONE 16

#define BARO_CORR_SIZE 4


#define AFTERSTART_HOLD_CURVE_SIZE 8
#define AFTERSTART_DECAY_CURVE_SIZE 8
#define AFTERSTART_ENRICH_CURVE_SIZE 8

custom fuel_table_t	4*@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@],"ms",      1,     0,      0.0,   500.0,   1
custom ve_table_t 4*@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@],"%", 1, 0, 0, 999.0, 1
custom afr_table_t @@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@ array,   U08,   @OFFSET@, [@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@],"deg",	   0.1,     0,        0,  25.0,     1 
custom fsio_table_8x8_f32t	4*@@FSIO_TABLE_8@@x@@FSIO_TABLE_8@@ array,   F32,   @OFFSET@, [@@FSIO_TABLE_8@@x@@FSIO_TABLE_8@@],"value",      1,     0,      0.0,   30000.0,   2

custom tps_tps_table_t	4*@@TPS_TPS_ACCEL_TABLE@@x@@TPS_TPS_ACCEL_TABLE@@ array,   F32,   @OFFSET@, [@@TPS_TPS_ACCEL_TABLE@@x@@TPS_TPS_ACCEL_TABLE@@],"value",      1,     0,      0.0,   30000.0,   2


custom baro_corr_table_t 4*@@BARO_CORR_SIZE@@x@@BARO_CORR_SIZE@@ array,   F32,   @OFFSET@, [@@BARO_CORR_SIZE@@x@@BARO_CORR_SIZE@@],"ratio", 1, 0, 0, 2.0, 2
custom ignition_table_t	4*@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@],"deg",	   1,     0,     -20, 90,    1
custom ignition_tps_table_t	2*@@IGN_RPM_COUNT@@x@@IGN_TPS_COUNT@@ array,   S16,   @OFFSET@, [@@IGN_RPM_COUNT@@x@@IGN_TPS_COUNT@@],"deg",	   0.01,     0,     -20, 90,    1

custom angle_table_t	4*@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@],"deg",	   1,     0,     -720,  720,    1
custom pedal_to_tps_t	@@PEDAL_TO_TPS_SIZE@@x@@PEDAL_TO_TPS_SIZE@@ array,   U08,   @OFFSET@, [@@PEDAL_TO_TPS_SIZE@@x@@PEDAL_TO_TPS_SIZE@@],"deg",	   1,     0,     -720,  720,    2
custom iac_pid_mult_t	@@IAC_PID_MULT_SIZE@@x@@IAC_PID_MULT_SIZE@@ array,   U08,   @OFFSET@, [@@IAC_PID_MULT_SIZE@@x@@IAC_PID_MULT_SIZE@@],"%",	   1,     0,     0,  999,    2
custom boost_table_t	@@BOOST_RPM_COUNT@@x@@BOOST_LOAD_COUNT@@ array,   U08,   @OFFSET@, [@@BOOST_RPM_COUNT@@x@@BOOST_LOAD_COUNT@@],"",    @@LOAD_1_BYTE_PACKING_MULT@@,  0 ,    0,    3000,      0

custom vvt_table_f32t	@@VVT_RPM_COUNT@@x@@VVT_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@VVT_RPM_COUNT@@x@@VVT_LOAD_COUNT@@],"value",      1,     0,      0.0,   30000.0,   2

#define GPPWM_LOAD_COUNT 8
#define GPPWM_RPM_COUNT 8
#define GPPWM_CHANNELS 4

custom gppwm_table_t	@@GPPWM_RPM_COUNT@@x@@GPPWM_LOAD_COUNT@@ array, U08, @OFFSET@, [@@GPPWM_RPM_COUNT@@x@@GPPWM_LOAD_COUNT@@], "duty", 1, 0, 0, 100, 0

#define ego_sensor_e_enum "BPSX", "Innovate", "14Point7", "Narrow", "PLX", "Custom", "AEM",  "Internal WideBand", "INVALID", "INVALID", "INVALID"
custom ego_sensor_e 4 bits, S32, @OFFSET@, [0:3], @@ego_sensor_e_enum@@

#define debug_mode_e_enum "Alternator PID", "TPS acceleration enrichment", "INVALID", "Idle Control", "Engine Load accl enrich", "Trigger Counters", "FSIO_ADC", "AUX_PID_1", "VVT input", "Cranking", "Timing", "Closed-loop fuel corr PID", "VSS", "SD card", "sr5", "Knock", "mode16", "Electronic Throttle", "Executor", "Bench Test / TS commands", "Aux Valves", "Analog inputs #1", "INSTANT_RPM", "FSIO_EXPRESSION", "Status", "CJ125", "CAN", "MAP", "Metrics", "ETB#2", "Ion Sense", "TLE8888", "Analog inputs #2", "Dwell Metric", "INVALID", "ETB Logic", "Boost Control", "Start/Stop", "Launch", "ETB Autotune", "Trigger Timing"
custom debug_mode_e 4 bits,    U32,   @OFFSET@, [0:7], @@debug_mode_e_enum@@

#define vvt_mode_e_enum "Inactive", "Second half", "2JZ/Universal", "Miata NB2", "First Half", "Bosch Quick-Start", "mode6", "mode7"
custom vvt_mode_e 4 bits,    U32,   @OFFSET@, [0:4], @@vvt_mode_e_enum@@

#define launchActivationMode_e_enum "Switch Input", "Clutch Input", "Always Active(Disabled By Speed)","INVALID"
custom launchActivationMode_e  4 bits, S32, @OFFSET@, [0:1], @@launchActivationMode_e_enum@@

#define brain_pin_e_enum       "NONE",   "INVALID", "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6","PE7","PE8","PE9","PE10","PE11","PE12","PE13","PE14","PE15",       "PF0","PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8","PF9","PF10","PF11","PF12","PF13","PF14","PF15",          "PG0","PG1","PG2","PG3","PG4","PG5","PG6","PG7","PG8","PG9","PG10","PG11","PG12","PG13","PG14","PG15",             "PH0","PH1","PH2","PH3","PH4","PH5","PH6","PH7","PH8","PH9","PH10","PH11","PH12","PH13","PH14","PH15","INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
#define switch_input_pin_e_enum       "NONE",   "INVALID", "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6","PE7","PE8","PE9","PE10","PE11","PE12","PE13","PE14","PE15",       "PF0","PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8","PF9","PF10","PF11","PF12","PF13","PF14","PF15",          "PG0","PG1","PG2","PG3","PG4","PG5","PG6","PG7","PG8","PG9","PG10","PG11","PG12","PG13","PG14","PG15",             "PH0","PH1","PH2","PH3","PH4","PH5","PH6","PH7","PH8","PH9","PH10","PH11","PH12","PH13","PH14","PH15","INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"

custom brain_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@brain_pin_e_enum@@
custom switch_input_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@switch_input_pin_e_enum@@

#define output_pin_e_enum       "NONE",   "INVALID", "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6","PE7","PE8","PE9","PE10","PE11","PE12","PE13","PE14","PE15",       "PF0","PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8","PF9","PF10","PF11","PF12","PF13","PF14","PF15",          "PG0","PG1","PG2","PG3","PG4","PG5","PG6","PG7","PG8","PG9","PG10","PG11","PG12","PG13","PG14","PG15",             "PH0","PH1","PH2","PH3","PH4","PH5","PH6","PH7","PH8","PH9","PH10","PH11","PH12","PH13","PH14","PH15","TLE6240_1",   "TLE6240_2",   "TLE6240_3",   "TLE6240_4",   "TLE6240_5",   "TLE6240_6",   "TLE6240_7",   "TLE6240_8",    "TLE6240_9",    "TLE6240_10",    "TLE6240_11",    "TLE6240_12",    "TLE6240_13",    "TLE6240_14",   "TLE6240_15",   "TLE6240_16",   "MC33972_1",   "MC33972_2",   "MC33972_3",   "MC33972_4",   "MC33972_5",   "MC33972_6",   "MC33972_7",   "MC33972_8",    "MC33972_9",    "MC33972_10",    "MC33972_11",    "MC33972_12",    "MC33972_13",    "MC33972_14",   "MC33972_15",   "MC33972_16",   "MC33972_17",   "MC33972_18",   "MC33972_19",   "MC33972_20",   "MC33972_21",   "MC33972_22", "TLE8888_1",   "TLE8888_2",   "TLE8888_3",   "TLE8888_4",   "TLE8888_5",   "TLE8888_6",   "TLE8888_7",   "TLE8888_8",    "TLE8888_9",    "TLE8888_10",    "TLE8888_11",    "TLE8888_12",    "TLE8888_13",    "TLE8888_14",   "TLE8888_15",   "TLE8888_16",   "TLE8888_17",   "TLE8888_18",   "TLE8888_19",   "TLE8888_20",   "TLE8888_21",   "TLE8888_22",   "TLE8888_23", "TLE8888_24", "TLE8888_25", "TLE8888_26", "TLE8888_27", "TLE8888_28", "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
custom output_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@output_pin_e_enum@@
 
#define antiLagAirSupply_e_enum "Solenoid","Idle Solenoid", "E-Throttle"
custom antiLagAirSupply_e  4 bits, S32, @OFFSET@, [0:1], @@antiLagAirSupply_e_enum@@

#define antiLagActivationMode_e_enum "Always Active", "Switch Input"
custom antiLagActivationMode_e  4 bits, S32, @OFFSET@, [0:0], @@antiLagActivationMode_e_enum@@

#define pin_output_mode_e_enum "default", "default inverted", "open collector", "open collector inverted"
custom pin_output_mode_e 1 bits,    U08,   @OFFSET@, [0:1], @@pin_output_mode_e_enum@@

custom vvtType_e 4 bits,   U32,   @OFFSET@, [0:1], "On/Off", "Closed Loop", "INVALID", "INVALID"

#define pin_input_mode_e_enum "Default", "Pull-Up", "Pull-Down", "INVALID"
custom pin_input_mode_e 1 bits, U08,	@OFFSET@, [0:1], @@pin_input_mode_e_enum@@

custom vvtLoadAxis_e 4 bits,   U32,   @OFFSET@, [0:1], "TPS", "MAP", "CLT", "INVALID"

#define gppwm_channel_e_enum "TPS", "MAP", "CLT", "IAT"
custom gppwm_channel_e 1 bits, U08, @OFFSET@, [0:1], @@gppwm_channel_e_enum@@

#define antiLagActivationMode_e_enum "Always Active", "Switch Input"
custom antiLagActivationMode_e  4 bits, S32, @OFFSET@, [0:0], @@antiLagActivationMode_e_enum@@

#define engine_load_mode_e_enum "INVALID", "INVALID", "INVALID", "Speed Density", "MAF Air Charge", "Alpha-N", "INVALID"
custom engine_load_mode_e 4 bits, U32, @OFFSET@, [0:2], @@engine_load_mode_e_enum@@

custom injection_mode_e 4 bits, U32, @OFFSET@, [0:1], "Simultaneous", "Sequential", "Batch", "Single Point"

custom ignition_mode_e 4 bits,    U32,    @OFFSET@, [0:1], "One coil", "Individual Coils", "Wasted", "Two distributors"

custom timing_mode_e 4 bits, U32, @OFFSET@ [0:2], "dynamic", "fixed", "INVALID", "INVALID"
	
custom can_nbc_e 4 bits, U32, @OFFSET@, [0:7], "None", "FIAT", "VAG" , "MAZDA RX8", "BMW", "W202"

custom operation_mode_e 4 bits,    U32,    @OFFSET@, [0:1], "INVALID", "Crank", "Cam", "INVALID"

custom uart_device_e 1 bits,U32,   @OFFSET@, [0:7], "Off", "UART1", "UART2", "UART3" 

custom pid_dt 4 scalar, U32,  @OFFSET@, "ms",      1,      0,       0, 3000,      0

custom adc_channel_mode_e 4 bits,    U32,   @OFFSET@, [0:7], "Off", "Slow", "Fast", "INVALID" 
	
#define pin_mode_e_enum "default", "INVALID", "INVALID", "INVALID", "opendrain", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PULLUP", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PULLDOWN"
custom pin_mode_e 1 bits,    U08,   @OFFSET@, [0:7], @@pin_mode_e_enum@@
	
custom idle_mode_e 4 bits,    U32,   @OFFSET@, [0:0], "Closed Loop", "Open Loop"

custom cfg_float_t_1f 4 scalar,  F32,   @OFFSET@, 		"Val",	   1,	   0,       -20000000, 20000000,	  1

custom boostType_e 4 bits,   U32,   @OFFSET@, [0:0], "Open Loop",  "Closed Loop"

custom tle8888filter_e 4 bits,   U32,   @OFFSET@, [0:1], "1 us",  "5 us",  "10 us",  "20 us"

custom tle8888detection_voltage_e 4 bits,   U32,   @OFFSET@, [0:1], "50 Mv",  "150 Mv",  "350 Mv",  "550 Mv"
custom trigger_filter_e 4 bits,   U32,   @OFFSET@, [0:1], "No Filter",  "Level 1", "Level 2", "Level 3"

custom tle8888vrpeak_time_e 4 bits,   U32,   @OFFSET@, [0:0], "10 Us",  "250 Us"

custom can_vss_nbc_e 4 bits, U32, @OFFSET@, [0:1], "BMW_e46", "W202", "VAG", "INVALID"

#define can_baudrate_e_enum "100kbps", "250kbps" , "500kbps", "1Mbps"
custom can_baudrate_e 1 bits, U08, @OFFSET@, [0:1], @@can_baudrate_e_enum@@

!
! lower 16 values are used on stm32, values above 16 are related to Kinetis work in progress
! 
#define adc_channel_e_enum "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PB0", "PB1", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "Disabled", "PB12", "PB13", "PC14", "PC15", "PC16", "PC17", "PD3", "PD4", "PE2", "PE6", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
custom adc_channel_e 1 bits, U08, @OFFSET@, [0:7]  @@adc_channel_e_enum@@

! At the moment TIM1, TIM2, TIM3 and TIM9 are configured as ICU
! todo: as of ChibiOS3, only channels 1 & 2 are allowed to capture input, that's a ChibiOS driver limitation
! https://github.com/ChibiOS/ChibiOS-Drivers/blob/master/inc/timcap_driver.h is an alternative driver if channels 3 & 4 really become an issue
! todo: only one channel per timer is allowed for capture simultaneously, that's an STM32 limitation
! todo: convert slow ADC to software scheduler and make TIM8 available
! todo: maybe convert fast ADC to software scheduler as well? less sure about that

#define brain_input_pin_e_enum "NONE",   "INVALID",  "INVALID", "PA1", "PA2", "PA3", "INVALID", "PA5", "PA6", "PA7", "PA8", "PA9", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PA15",  "INVALID", "INVALID", "INVALID", "PB3", "PB4", "PB5", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PC6", "PC7", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PE5", "PE6", "INVALID", "INVALID", "PE9", "INVALID", "PE11", "INVALID", "INVALID", "INVALID", "INVALID",     "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
custom brain_input_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@brain_input_pin_e_enum@@



struct stft_cell_cfg_s
	int8_t maxAdd;;    "%",        1, 0,  0, 25, 0
	int8_t maxRemove;; "%",        1, 0, -25, 0, 0
	uint16_t timeConstant;;   "sec", 0.1, 0, 0.1,  100, 2
end_struct

struct stft_s
	uint8_t maxIdleRegionRpm;+Below this RPM, the idle region is active;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0
	uint8_t maxOverrunLoad;+Below this engine load, the overrun region is active;  "load",  1,    0,      0.0,   250,   0
	uint8_t minPowerLoad;+Above this engine load, the power region is active;    "load",  1,    0,      0.0,   250,   0
	uint8_t deadband;+When close to correct AFR, pause correction.  This can improve stability by not chan the adjustment if the error is extremely small, but is not required.;  "%",  0.1,     0,    0,      3,  1
	int8_t minClt;+Below this temperature, correction is disabled.;"C",         1,     0,  -20,    100,  0
	uint8_t minAfr;+Below this AFR, correction is paused;"afr",    0.1,     0,   10,     20,  1
	uint8_t maxAfr;+Above this AFR, correction is paused;"afr",    0.1,     0,   10,     20,  1
	uint8_t startupDelay;+Delay after starting the engine before beginning closed loop correction.;"seconds", 1, 0, 0, 250, 0
	stft_cell_cfg_s[STFT_CELL_COUNT iterate] cellCfgs;
end_struct

struct pid_s
	float pFactor;;"",      1,      0,       -10000, 10000,      3
	float iFactor;;"",      1,      0,       -10000, 10000,      3
	float dFactor;;"",      1,      0,       -10000, 10000,      3
	int16_t fsio_visible offset;Linear addition to PID logic;"",      1,      0,       -1000, 1000,      0
	int16_t periodMs;PID dTime;"ms",      1,      0,       0, 3000,      0
	int16_t fsio_visible minValue;Output min value;"",        1,     0,  -30000,    30000.0,  0
	int16_t maxValue;Output max value;"",        1,     0,  -30000,    30000.0,  0
end_struct

struct cranking_parameters_s
	float baseFuel;+Base duration of the fuel injection during cranking, this is modified by the multipliers for CLT, IAT, TPS ect, to give the final cranking pulse width.;"ms",       1,     0,    0, 200,     1
	int16_t pad;
	int16_t rpm;+This sets the RPM limit below which the ECU will use cranking fuel and ignition logic, typically this is around 350-450rpm. \nset cranking_rpm X;"RPM",      1,     0,    0, 3000,      0
end_struct


struct gppwm_channel
	output_pin_e pin;+Select a pin to use for PWM or on-off output.;
	uint8_t dutyIfError;+If an error (with a sensor, etc) is detected, this value is used instead of reading from the table.\nThis should be a safe value for whatever hardware is connected to prevent damage.;"%", 1, 0, 0, 100, 0
	uint16_t pwmFrequency;+Select a frequency to run PWM at.\nSet this to 0hz to enable on-off mode.;"hz", 1, 0, 0, 500, 0

	uint8_t onAboveDuty;+In on-off mode, turn the output on when the table value is above this duty.;"%", 1, 0, 0, 100, 0
	uint8_t offBelowDuty;+In on-off mode, turn the output off when the table value is below this duty.;"%", 1, 0, 0, 100, 0

	gppwm_channel_e loadAxis;+Selects the load axis to use for the table.;
	uint8_t[1] pad;
	uint8_t[GPPWM_LOAD_COUNT] loadBins;;"load",      1,     0,   0.0,    250,   0
	uint8_t[GPPWM_RPM_COUNT] rpmBins;;"RPM",  @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0
	gppwm_table_t table;
end_struct

struct air_pressure_sensor_config_s
	float lowValue;kPa value at low volts;"kpa",      1,     0,    -400, 800,     2
	float highValue;kPa value at high volts;"kpa",      1,     0,    -400, 800,     2
	adc_channel_e hwChannel;
	uint8_t[3] align;
end_struct

struct MAP_sensor_config_s @brief MAP avera configuration
	air_pressure_sensor_config_s sensor
end_struct

struct_no_prefix thermistor_conf_s @brief Thermistor known values
	float tempC_1;these values are in Celcius;"*C",       1,     0,    -40, 200,     1
	float tempC_2;;"*C",       1,     0,    -40, 200,     1
	float tempC_3;;"*C",       1,     0,    -40, 200,     1
	float resistance_1;;"Ohm",      1,     0,    0, 200000,     1
	float resistance_2;;"Ohm",      1,     0,    0, 200000,     1
	float resistance_3;;"Ohm",      1,     0,    0, 200000,     1
	float bias_resistor;+Pull-up resistor value on your board;"Ohm",      1,     0,    0, 200000,     1
end_struct

struct oil_pressure_config_s @brief Oil pressure sensor interpolation
	adc_channel_e hwChannel;
	uint8_t[3] align;
	float v1;;         "volts",    1,    0.0,       0,    10.0,        2
	float value1;;     "kPa",    1,      0.0,       0,  1000.0,        2
	float v2;;         "volts",    1,    0.0,       0,    10.0,        2
	float value2;;     "kPa",    1,      0.0,       0,  1000.0,        2
end_struct

struct ThermistorConf @brief Thermistor curve parameters
	thermistor_conf_s config;
	adc_channel_e adcChannel;
	uint8_t[3] pad;
end_struct

struct injector_s
	float size;+This is your injector flow at the fuel pressure used in the vehicle. cc/min, cubic centimetre per minute\nBy the way, g/s = 0.125997881 * (lb/hr)\ng/s = 0.125997881 * (cc/min)/10.5\ng/s = 0.0119997981 * cc/min;"cm3/min",  1,     0,      0,  99999,   2
	float[VBAT_INJECTOR_CURVE_SIZE] battLagCorrBins;set_flat_injector_lag LAG\nset_injector_lag VOLTAGE LAG;"volts",        1,     0,      0.0,    20.0,   2
	float[VBAT_INJECTOR_CURVE_SIZE] battLagCorr;ms delay between injector open and close dead times;"ms",     1,     0,      0.0,    50.0,   2
end_struct

struct antilag_s
    int antiLagTpsTreshold;+This level of throttle position (TP(Main)) needs to be exceeded before Anti-Lag becomes active. Anti-Lag will stay active as long as TP(Main) is above this value. Once the throttle position falls below this value, Anti-Lag will remain active until the AL Deactivation Timeout has elapsed.;"RPM",       1,  0,  0,  8000.0, 0 
	int antiLagCoolantTreshold;+Minimum Coolant temperature before AntiLag arms;"*C",    1,  0,  0,  1000.0, 0 
	int antiLagExtraFuel;+Additional fuel when AntiLag are armed. Should only be used together with retard;"%",    1,  0,  0,  1000.0, 0 
	int antilagExtraAir;+This function overrides the current position of the idle speed solenoid, E-Throttle or stepper motor. This override is used to bleed extra air into the engine when Anti-Lag is active. A standard Idle valve does generally not flow enough air for proper Anti-Lag operation, an after market upgrade is often necessary.;"%",        1,     0,  0,    100.0,  0
	int antilagTimeout;+This function specifies the time after the engine speed (RPM) falls below the AL Enable RPM AND the throttle position (TP(Main)) falls below the AL Enable TP that Anti-Lag remains active for. This is the time that the turbo will remain spooled for once stepping off the throttle.;"Sec",    1,      0,       0, 50,        1
	int antiLagRetard;+Sets the current Ignition Retard value as the current Ignition Timing.;"ATDC",    1,  0,  0,  1000.0, 0 
	int antiLagBoost;+Sets the Boost Valve Duty when AntiLag are active;"%",    1,  0,  0,  1000.0, 0 
	int antiLagRpmTreshold;+This engine speed (RPM) needs to be exceeded before Anti-Lag becomes active. Anti-Lag will stay active as long as the engine speed (RPM) is above this value. Once the engine speed (RPM) falls below this value, Anti-Lag will remain active until the AL Deactivation Timeout has elapsed.;"RPM",        1,     0,  0,    8000.0,  0
	antiLagAirSupply_e antiLagAirSupply;
 	antiLagActivationMode_e antiLagActivationMode;+The Anti-lag system will remain OFF until the system is armed. This means Anti-Lag will not work until the arming condition(s) is met. Various methods can be used including a Digital Input, an Always ON option allowing the system to be armed permanently.
end_struct

struct_no_prefix specs_s
	float displacement;Engine displacement, in litres\nsee also cylindersCount;"L",    1,      0,       0,  1000.0,        2
	custom cylinders_count_t 4 bits,    U32,    @OFFSET@, [0:3], "INVALID", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, "INVALID", "INVALID", "INVALID"
	cylinders_count_t cylindersCount;
	custom firing_order_e 4 bits,    U32,    @OFFSET@, [0:7], "One Cylinder", "1-3-4-2", "1-2-4-3", "1-3-2-4", "1-5-3-6-2-4", "1-8-4-3-6-5-7-2", "1-2-4-5-3", "1-4-2-5-3-6", "1-2", "1_2_3_4_5_6", "1-2-3", "1-8-7-2-6-5-4-3", "1-5-4-2-6-3-7-8", "1-6-3-2-5-4", "1-10-9-4-3-6-5-8-7_2", "1-7-5-11-3-9-6-12-2-8-4-10", "1-7-4-10-2-8-6-12-3-9-5-11", "1-4-3-2", "1-12-5-8-3-10-6-7-2-11-4-9", "1-2-7-8-4-5-6-3", "1-3-7-2-6-5-4-8", "1-2-3-4-5-6-7-8-9", "fo22", "fo23", "fo24", "fo25", "INVALID"
	firing_order_e firingOrder;
end_struct

struct trigger_config_s @brief Trigger wheel(s) configuration
	custom bool32_t 4 bits,    U32,   @OFFSET@, [0:0], "No", "Yes"
	#define trigger_type_e_enum "custom toothed wheel", "Ford Aspire", "INVALID", "Miata NA", "Miata NB", "GM_7X", "Cooper R50", "Mazda SOHC 4", "60-2", "36-1", "Honda 4+24+1", "Mitsubishi", "Honda 4+24", "Honda 1+4+24", "Dodge Neon", "Mazda DOHC 1+4", "1+1", "1+60-2", "Single Tooth", "Dodge Ram 1+16", "60-2 VW", "Honda 1+24", "INVALID",  "36_2_2_2", "Nissan Primera", "dev 2JZ 3/34 simulator", "Rover K", "GM LS 24", "Honda CBR 600", "2JZ_1_12", "INVALID", "3-1 skipped" , "INVALID", "Miata VVT", "trg34", "trg35", "Subaru 7+6", "Jeep 18-2-2-2", "INVALID", "INVALID", "Jeep XJ 4 cyl", "FiatIAQ_P8", "Mazda Z5", "trg43", "Renix 44-2-2", "Renix 66-2-2-2", "Honda K 12+1", "Bosch Quick-Start", "36-2", "Subaru SVX", "Vw 60-2 VVT", "Trg 51"
	custom trigger_type_e 4 bits,    U32,   @OFFSET@, [0:5], @@trigger_type_e_enum@@

	trigger_type_e type;set trigger_type X
	uint8_t[4] unused95
	int numTeeth;;"number",    1,      0.0,       0,  500.0,        0
	int missingTeeth;;"number",    1,      0.0,       0,  500.0,        0
end_struct

struct afr_sensor_s
	adc_channel_e hwChannel;
	uint8_t[3] alignAf;
	float v1;;         "volts",    1,    0.0,       0,    10.0,        2
	float value1;;     "AFR",    1,      0.0,       0,  1000.0,        2
	float v2;;         "volts",    1,    0.0,       0,    10.0,        2
	float value2;;     "AFR",    1,      0.0,       0,  1000.0,        2
end_struct	

struct idle_hardware_s
	int solenoidFrequency;;"Hz",      1,      0,       0, 3000,      0
	output_pin_e solenoidPin;
	brain_pin_e pinStepperDirection;
	brain_pin_e stepperStepPin; 
	pin_output_mode_e solenoidPinMode;
end_struct

struct etb_io
	brain_pin_e directionPin1;
	brain_pin_e directionPin2;
	brain_pin_e controlPin1;
	brain_pin_e disablePin;
end_struct

struct launch_s
    launchActivationMode_e launchActivationMode;
	int launchRpm;A secondary Rev limit engaged by the driver to help launch the vehicle faster;"rpm",    1,      0,       0, 20000.0,        2
	int launchTimingRetard;;"deg",    1,      0,       -180, 180,        2
    int launchSpeedTreshold;+Disabled above this speed;"Kph",        1,     0,  0,    300.0,  0
    int launchRpmTreshold;+Disabled below this rpm;"RPM",        1,     0,  0,    8000.0,  0
    int launchAdvanceRpmRange;+Range from Launch Rpm for Timing Retard to activate;"RPM",        1,     0,  0,    8000.0,  0
    int launchFuelAdded;+Extra Fuel Added;"%",        1,     0,  0,    100.0,  0
    int launchBoostDuty;+Duty Cycle for the Boost Solenoid;"%",        1,     0,  0,    100.0,  0
	int hardCutRpmRange;+RPM Range for Hard Cut;"rpm",    1,      0,       0, 3000.0,        2
	int unused97
    int launchTpsTreshold;;"%",        1,     0,  0,    8000.0,  
	float launchActivateDelay;+Time in Seconds;"Sec",    1,      0,       0, 50,        
end_struct
	        
struct vvtsettings
    vvtLoadAxis_e vvtLoadAxis
	float minVvtTemperature;;"*C",    1,      0,       0,  1000.0, 0
	int vvtPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
	vvtType_e vvtType;
	pid_s vvtPid;
	int maxVvtDeviation;;"Angle",        1,     0, -50,    50,  1
    output_pin_e vvtControlPin;
	pin_output_mode_e vvtControlPinMode;
	uint8_t[2] pad
end_struct

int unused81
	
	injector_s injector
	trigger_config_s trigger;
	specs_s specs
	

	int rpmLimit;set rpm_hard_limit X;"rpm",    1,      0,       0, 20000.0,        2

	engine_load_mode_e fuelAlgorithm;+This setting controls which fuel quantity control algorithm is used.\nSee also useTPSAdvanceTable\nset algorithm X

	injection_mode_e crankingInjectionMode;+This is the injection strategy during engine start.  See Fuel/Injection settings for more detail. It is suggested to use "Simultaneous".
	injection_mode_e injectionMode;+This is where the fuel injection type is defined: "Simultaneous" means all injectors will fire together at once. "Sequential" fires the injectors on a per cylinder basis, which requires individually wired injectors. "Batched" will fire the injectors in groups.  If your injectors are individually wired you will also need to enable "Two wire batch emulation". \nset injection_mode X\nSee also twoWireBatchInjection	
	angle_t extraInjectionOffset;+this is about deciding when the injector starts it's squirt\nSee also injectionPhase map\ntodo: do we need even need this since we have the map anyway?;"deg",    1,      0.0,       -720,     720,        2
	angle_t fixedCrankingTiming;+Ignition advance angle used during engine cranking, 5-10 degrees will work as a base setting for most engines.\nset cranking_timing_angle X;     "deg",    1,      0.0,    -360,     360,        2
	ignition_mode_e ignitionMode;+"One Coil" is for use on distributed ignition system. "Individual Coils" is to be used when you have one coil per cylinder (COP or similar). "Wasted" means one coil is driving two spark plugs in two cylinders, with one of the sparks not doing anything since it's happening on the exhaust cycle\nset ignition_mode X
	angle_t ignitionOffset;+this value could be used to offset the whole ignition timing table by a constant;"RPM",    1,      0,       0,  3000.0,      0	
	timing_mode_e timingMode;+Dynamic uses the timing map to decide the ignition timing, Static timing fixes the timing to the value set below (only use for checking static timing).
	angle_t fixedModeTiming;+This value is the ignition timing used when in 'fixed timing' mode, i.e. constant timing\nThis mode is useful when adjusting distributor location.;"RPM",    1,      0,       0,  3000.0,      0
	angle_t globalTriggerAngleOffset;+Angle between Top Dead Center (TDC) and the first trigger event.\nKnowing this angle allows us to control timing and other angles in reference to TDC.\nset global_trigger_offset_angle X;"deg",    1,      0,       -720,  720, 0


	operation_mode_e ambiguousOperationMode;




	bit enableThrottlePumps
	bit cj125isLsu49,LSU 4.9,LSU 4.2
	bit etb_use_two_wires,Yes,No
	bit isDoubleSolenoidIdle,Yes,No
	
	bit enableTpsTpsAe
	bit useTLE8888_cranking_hack,Yes,No
	bit useInstantRpmForIdle,Yes,No
	bit absoluteFuelPressure,Yes,No;+If your fuel regulator does not have vacuum line
	
	bit launchControlEnabled,Yes,No
	bit antiLagEnabled,Yes,No
	bit useRunningMathForCranking,Fuel Map,Fixed;
	bit displayLogicLevelsInEngineSniffer;
	
	bit triggerTestMinGap
	bit triggerTestMaxEvents
	bit triggerDisableError
	bit useCicPidForIdle,Yes,No
	
	bit isCJ125Enabled,Yes,No
	bit vvtCamSensorUseRise,Rising,Falling;
	bit measureMapOnlyInOneCylinder,Yes,No;+Useful for individual intakes
	bit stepperForceParkingEveryRestart,Yes,No
	
	bit isFasterEngineSpinUpEnabled,Yes,No;+Smarter cranking logic.\nSee also startOfCrankingPrimingPulse
	bit enableDfco,Yes,No;+This setting disables fuel injection while the engine is in overrun, this is useful as a fuel saving measure and to prevent back firing.
	bit useIacTableForCoasting,Yes,No;+This setting allows the ECU to open the IAC during overrun conditions to help reduce engine breaking, this can be helpful for large engines in light weight cars.
	bit enableTriggerFilter,Yes,No
	
	bit useSerialPort,Yes,No
	bit useStepperIdle,Yes,No;+This setting should only be used if you have a stepper motor idle valve and a stepper motor driver installed. 	
	bit enableVerboseCanTx,Yes,No
	bit onOffAlternatorLogic,Yes,No; +This will cause the alternator to be operated in a basic on or off mode, this is the simplest alternator control.
	
	bit alignEngineSnifferAtTDC,Yes,No
	bit useETBforIdleControl,Yes,No;+This setting allows the ETB to act as the idle air control valve and move to regulate the airflow at idle.
	bit idleIncrementalPidCic,Yes,No
	bit enableAemXSeries,Yes,No
	
int unused99

	bit fuelClosedLoopCorrectionEnabled,Yes,No;+Enables lambda sensor closed loop feedback for fuelling.
	bit enableFixedDwellCranking,Yes,No;+If set to true, will use the specified duration for cranking dwell. If set to false, will use the specified dwell angle.  Unless you have a really good reason to, leave this set to true to use duration mode.
	bit useLinearCltSensor,Yes,No
	bit canReadEnabled,Yes,No

	bit canWriteEnabled,Yes,No
	bit useLinearIatSensor,Yes,No	
	bit tachPulseDurationAsDutyCycle,Yes,No
	bit enableAlternatorControl,Yes,No;+This enables smart alternator control and activates the extra alternator settings.
	
	bit trigger1Edge,Normal,Inverted;
	bit trigger2Edge,Rising,Falling;+This setting flips the signal from the secondary engine speed sensor.
	bit cutFuelOnHardLimit,Yes,No
	bit cutSparkOnHardLimit,Yes,No

	bit enableLaunchFuelCut,Yes,No
	bit enableLaunchIgnCut,Yes,No;+This is the Cut Mode normally used	
	bit useIdleTimingPidControl,Yes,No
	bit useTPSBasedVeTable,Yes,No

	bit invertCamVVTSignal,Yes,No
	bit todoClutchDownPinInverted,Yes,No
	bit useHbridges,Yes,No
	bit multisparkEnable,Yes,No
	
	bit enableCanVss
	bit enableInnovateLC2
	bit enableLaunchBoost,Yes,No
	bit stftIgnoreErrorMagnitude;+If enabled, adjust at a constant rate instead of a rate proportional to the current lambda error.  This mode may be easier to tune, and more tolerant of sensor noise.  Use of this mode is required if you have a narrowband O2 sensor.
	
	bit silentTriggerError,Yes,No
	bit useSolenoidIdle,Yes,No
	bit useSecondEtb,Yes,No
	bit enableAntiLagAir,Yes,No
	
	bit enableAntiLagFuel,Yes,No
	bit syncMode,Yes,No	
	bit useLaunchActivateDelay,Yes,No
	bit isVvtControlEnabled,Yes,No
	

int unused75

	bit enableInjectors,Yes,No;
	bit enableIgnition,Yes,No;
	bit isCylinderCleanupEnabled,Yes,No;+When enabled if TPS is held above 95% no fuel is injected while cranking to clear excess fuel from the cylinders. 
	bit secondTriggerChannelEnabled,Yes,No
	
	bit overrideCrankingIacSetting,Yes,No;+This setting overrides the normal multiplication values that have been set for the idle air control valve during cranking. If this setting is enabled the "IAC multiplier" table in the Cranking settings tab needs to be adjusted appropriately or potentially no IAC opening will occur.
	bit useSeparateAdvanceForIdle,Yes,No;+This activates a separate ignition timing table for idle conditions, this can help idle stability by using ignition retard and advance either side of the desired idle speed. Extra retard at low idle speeds will prevent stalling and extra advance at high idle speeds can help reduce engine power and slow the idle speed.
	bit useSeparateVeForIdle,Yes,No;+This activates a separate fuel table for Idle, this allows fine tuning of the idle fuelling.	
	bit isManualSpinningMode,Yes,No;Usually if we have no trigger events that means engine is stopped\nUnless we are troubleshooting and spinning the engine by hand - this case a longer\ndelay is needed

	bit twoWireBatchInjection,Yes,No;+This is needed if your coils are individually wired and you wish to use batch injection.\nenable two_wire_batch_injection
	bit useOnlyRisingEdgeForTrigger,VR,Hall;
	bit twoWireBatchIgnition,Yes,No;+This is needed if your coils are individually wired (COP) and you wish to use batch ignition (wasted spark).	
	bit useFixedBaroCorrFromMap,Yes,No

	bit enableCrankingTimingTable,Yes,No;+This activates a separate advance table for cranking conditions, this allows cranking advance to be RPM dependant.
	bit useAdvanceCorrectionsForCranking,Yes,No;+This enables the various ignition corrections during cranking (IAT, CLT, FSIO and PID idle).
	bit useTPSAdvanceTable,Yes,No;+This flag allows to use TPS for ignition lookup while in Speed Density Fuel Mode	
	bit useIacPidMultTable,Yes,No;+This flag allows to use a special 'PID Multiplier' table (0.0-1.0) to compensate for nonlinear nature of IAC-RPM controller

	bit isBoostControlEnabled,Yes,No
	bit launchSmoothRetard,Yes,No;+Interpolates the Ignition Retard from 0 to 100% within the RPM Range	
	bit verboseTriggerSynchDetails,Yes,No
	bit sensorType,Hall,VR

	bit dcMotorIdleValve;+Used on some German vehicles around late 90s: cable-operated throttle and DC motor idle air valve.\nSet the primary TPS to the cable-operated throttle's sensor\nSet the secondary TPS to the mini ETB's position sensor(s).
	bit enableAntiLagBoost,Yes,No
	bit enableAntiLagRetard,Yes,No
	bit launchDisableBySpeed,Yes,No
	
	bit enableLaunchRetard,Yes,No
	bit tuneCj125Pid,Yes,No
	bit cj125AutoChangeMode,Yes,No
	bit diagnoseTLE8888,Yes,No
	
	bit enableLaunchFuel,Yes,No
	bit invertLaunchSwitch,Yes,No
	bit isVerboseTriggerSynchDetails
	bit verboseVVTDecoding

	adc_channel_e auxFastSensor1_adcChannel;Useful in Research&Development phase
	adc_channel_e tps1_2AdcChannel;First throttle body, second sensor.
	adc_channel_e tps2_2AdcChannel;Second throttle body, second sensor.
	adc_channel_e throttlePedalPositionSecondAdcChannel;Electronic throttle pedal position input\nSecond channel\nSee also tps1_1AdcChannel


	adc_channel_e tps1_1AdcChannel;First throttle body, first sensor. See also pedalPositionAdcChannel
	adc_channel_e vbattAdcChannel;+This is the processor input pin that the battery voltage circuit is connected to, if you are unsure of what pin to use, check the schematic that corresponds to your PCB. 
	adc_channel_e fuelLevelSensor;+This is the processor pin that your fuel level sensor in connected to. This is a non standard input so will need to be user defined. 
	adc_channel_e tps2_1AdcChannel;Second throttle body position sensor, single channel so far\nset_analog_input_pin tps2 X

	
	adc_channel_e high_fuel_pressure_sensor_1;
	adc_channel_e high_fuel_pressure_sensor_2;
	adc_channel_e mafAdcChannel;See hasMafSensor
	adc_channel_e throttlePedalPositionAdcChannel;Electronic throttle pedal position input\nFirst channel\nSee also tps1_1AdcChannel\nset_analog_input_pin pps X
	
	uint8_t[2] unused120
	adc_channel_e auxVoltage1;
	adc_channel_e auxVoltage2;

	adc_channel_e externalKnockSenseAdc;
	adc_channel_e hipOutputChannel;
	adc_channel_e acSwitchAdc;A/C button input handled as analogue input
	adc_channel_e vRefAdcChannel;
	
	output_pin_e[INJECTION_PIN_COUNT iterate] pinInjector;
	output_pin_e[IGNITION_PIN_COUNT iterate] pinCoil;
	
	output_pin_e pinAlternator;
	output_pin_e pinFuelPump;
	output_pin_e pinFan;
	output_pin_e pinMainRelay;
	
	output_pin_e pinAcRelay;
	output_pin_e pinTacho;+This implementation produces one pulse per engine cycle. See also dizzySparkOutputPin.
	output_pin_e pinStartRelay;
	output_pin_e boostControlPin;
	
	output_pin_e starterControlPin;See also startStopButtonPin
	
	uint8_t[3] unused104

	pin_output_mode_e pinTachoMode;
	pin_output_mode_e pinFuelPumpMode;
	pin_output_mode_e pinInjectorMode;
	pin_output_mode_e sparkEdge;

	pin_output_mode_e pinFanMode;
	pin_output_mode_e pinAlternatorMode;
	pin_output_mode_e pinMainRelayMode;
	pin_output_mode_e pinAcRelayMode;
	
	pin_output_mode_e starterRelayDisableMode;On some vehicles we can disable starter once engine is already running
	pin_output_mode_e pinStepperDirectionMode;
	pin_output_mode_e boostControlPinMode;
	pin_output_mode_e pinStepperEnableMode;
	
	uint8_t[3] unused17
	brain_pin_e pinStepperEnable;

	bit enableSoftwareKnock

	int[1] unused117;
	
	brain_pin_e canTxPin;
	brain_pin_e canRxPin;
	brain_pin_e secondSolenoidPin;Some Subaru and some Mazda use double-solenoid idle air valve
	brain_pin_e binarySerialRxPin
	brain_pin_e binarySerialTxPin

	uint8_t[5] unused111
	output_pin_e triggerErrorPin
	output_pin_e debugTriggerSync
	pin_output_mode_e triggerErrorPinMode
	pin_output_mode_e debugTriggerSyncMode
	brain_pin_e auxSerialTxPin;set_aux_tx_pin X;	
	brain_pin_e auxSerialRxPin;set_aux_rx_pin X;

	switch_input_pin_e tcuUpshiftButtonPin
	switch_input_pin_e tcuDownshiftButtonPin
	switch_input_pin_e clutchUpPin;Some vehicles have a switch to indicate that clutch pedal is all the way up
 	switch_input_pin_e antiLagActivatePin;
    
	switch_input_pin_e launchActivatePin;
	switch_input_pin_e brakePedalPin;Brake pedal switch
	switch_input_pin_e throttlePedalUpPin;+Throttle Pedal not pressed switch - used on some older vehicles like early Mazda Miata
	switch_input_pin_e clutchDownPin;some cars have a switch to indicate that clutch pedal is all the way down
	
	switch_input_pin_e startStopButtonPin;See also starterControlPin
	uint8_t[3] unused105
	
	pin_input_mode_e startStopButtonMode;
	pin_input_mode_e clutchDownPinMode;
	pin_input_mode_e clutchUpPinMode;
	pin_input_mode_e brakePedalPinMode;
	
	pin_input_mode_e throttlePedalUpPinMode;
	uint8_t[3] unused108
   	
	brain_input_pin_e[CAM_INPUTS_COUNT iterate] pinCam;+Camshaft input could be used either just for engine phase detection if your trigger shape does not include cam sensor as 'primary' channel, or it could be used for Variable Valve timing on one of the camshafts.\nTODO #660
	
	brain_input_pin_e[TRIGGER_INPUT_PIN_COUNT iterate] pinTrigger;
	uint8_t unused109
	
	brain_input_pin_e vehicleSpeedSensorInputPin;
	uint8_t[3] unused54
	
	etb_io[ETB_COUNT iterate] etbIo
	etb_io[ETB_COUNT iterate] etbIo2

	int unused107
	debug_mode_e debugMode;
	
	cranking_parameters_s cranking
	

	float primingSquirtDurationMs;;"*C",       1,     0,    -40, 200,     1
	float ignitionDwellForCrankingMs;Used if enableFixedDwellCranking is TRUE;"ms",        1,     0,    0, 200,     1
	float crankingChargeAngle;+While cranking (which causes battery voltage to drop) we can calculate dwell time in shaft\ndegrees, not in absolute time as in running mode.\nset cranking_charge_angle X;"deg",    1,      0,       0,  3000.0,      0


	MAP_sensor_config_s map;
	ThermistorConf clt;todo: merge with channel settings, use full-scale Thermistor here!
	ThermistorConf iat;
	ThermistorConf auxTempSensor1;todo: finish implementation #332
	ThermistorConf auxTempSensor2;todo: finish implementation #332
	afr_sensor_s afr
	air_pressure_sensor_config_s baroSensor;@see hasBaroSensor	
	ego_sensor_e afr_type;AFR, WBO, EGO - whatever you like to call it;


    
	float analogInputDividerCoefficient;+Ratio/coefficient of input voltage dividers on your PCB. For example, use '2' if your board divides 5v into 2.5v. Use '1.66' if your board divides 5v into 3v.;"coef",    1,      0,    0.01,  10.0,   2
	float vbattDividerCoeff;+This is the ratio of the resistors for the battery voltage, measure the voltage at the battery and then adjust this number until the gauge matches the reading.;"coef",    1,      0,    0.01,  99.0,        2

	float fanOnTemperature;+Cooling fan turn-on temperature threshold, in Celsius;"*C",    1,      0,       0,  1000.0,        0
	float fanOffTemperature;+Cooling fan turn-off temperature threshold, in Celsius;"*C",    1,      0,       0,  1000.0,        0


	float vehicleSpeedCoef;+This coefficient translates vehicle speed input frequency (in Hz) into vehicle speed, km/h;"coef",    1,      0,    0.01,  2000.0,        2

	can_nbc_e canNbcType;set can_mode X

	
	int unused122
	int canSleepPeriodMs;CANbus thread period, ms;"ms",    1,      0,       0,  1000.0,        2
	int unused123
	int triggerSimulatorFrequency;+Same RPM is used for two ways of producing simulated RPM. See also triggerSimulatorPins (with wires)\nSee also directSelfStimulation (no wires, bypassing input hardware)\nrpm X;"Rpm",     1,      0,       0,30000,      0


    int boostPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
	int alternatorPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
	int ignMathCalculateAtIndex;+At what trigger index should some ignition-related math be executed? This is a performance trick to reduce load on synchronization trigger callback.;"index",      1,      0,       0, 7000,      0

	float globalFuelCorrection;set global_fuel_correction X;"coef",    1,      0.0,       0,  1000.0,        2

	float adcVcc;;         "volts",    1,    0.0,       0,    6.0,        3
	float maxKnockSubDeg;maximum total number of degrees to subtract from ignition advance\nwhen knocking;"Deg",      1,      0,       0, 100,      0
	float manIdlePosition;value between 0 and 100 used in Manual mode;"%", 1, 0, 0, 100, 0
	float fuelLevelEmptyTankVoltage;;"V",      1,      0,       0,10,      2
	float fuelLevelFullTankVoltage;;"V",      1,      0,       0,10,      2
	
	idle_hardware_s idle;

	uint32_t tunerStudioSerialSpeed;;"BPs",      1,      0,       0,1000000,      0

	! 536870911 = 2^29-1, the maximum valid extended ID
	uint32_t verboseCanBaseAddress;;"", 1, 0, 0, 536870911, 0


	uint8_t mc33_hvolt;;"v",        1,     0,  0,    100,  0
	uint8_t multisparkMaxSparkingAngle;;"deg", 1, 0, 0, 180, 0
	uint8_t multisparkMaxExtraSparkCount;;"count", 1, 0, 0, 10, 0
	uint8_t tachPulsePerRev;;"Pulse",        1,     0,  1.0,    255.0,  0

	int16_t idlePidDeactivationTpsThreshold;;"%",        1,     0,  0,    100.0,  0
	int16_t stepperParkingExtraSteps;;"%",        1,     0,  0,    3000.0,  0
	
	int16_t tpsMin;Closed throttle. todo: extract these two fields into a structure\nSee also tps1_1AdcChannel\nset tps_min X;"ADC",      1,     0,    0, 1023,      0
	int16_t tpsMax;Full throttle. tpsMax value as 10 bit ADC value. Not Voltage!\nSee also tps1_1AdcChannel\nset tps_max X;"ADC",      1,     0,    0, 1023,      0

	uint16_t tps2SecondaryMin;;"ADC", 1, 0, 0, 1000, 0
	uint16_t tps2SecondaryMax;;"ADC", 1, 0, 0, 1000, 0

	int16_t tpsErrorDetectionTooLow;+TPS error detection, what TPS % value is unrealistically low;"%",       1,     0,    -40, 200,     0
	int16_t tpsErrorDetectionTooHigh;+TPS error detection, what TPS % value is unrealistically high;"%",       1,     0,    -40, 200,     0

	uint16_t tps1SecondaryMin;;"ADC", 1, 0, 0, 1000, 0
	uint16_t tps1SecondaryMax;;"ADC", 1, 0, 0, 1000, 0
	
	int16_t unusedantiLagRpmTreshold;
	int16_t startCrankingDuration;Maximum time to crank starter;"Seconds",      1,      0,       0, 30,      0

	uint16_t multisparkMaxRpm;;"rpm", 1, 0, 0, 3000, 0
	int16_t acCutoffLowRpm;
	
	int16_t acCutoffHighRpm;
	int16_t acIdleRpmBump;
	
	int16_t warningPeriod;set warningPeriod X;"seconds",      1,      0,       0, 60,      0
	int16_t etbFreq;;"Hz",      1,     0,    0, 30000,      0



	
	pid_s idleRpmPid2
	pid_s idleTimingPid;See useIdleTimingPidControl
	pid_s idleRpmPid;See cltIdleRpmBins
	pid_s alternatorControl;
	pid_s etb;
    pid_s boostPid;


	idle_mode_e idleMode;See also idleRpmPid;
    boostType_e boostType;
	stft_s stft

	antilag_s antiLag;
 	vvtsettings vvt;  
    launch_s launch



	int16_t idlePidRpmUpperLimit;+Relative to the target idle RPM;"",      1,      0,       0, 9000,      0
    int16_t primeInjFalloffTemperature;+This sets the temperature above which no priming pulse is used, The value at -40 is reduced until there is no more priming injection at this temperature.;"*C",    1,      0,       0,  1000.0,        0


	float knockDetectionWindowStart;;"angle",      1,      0,       -1000, 1000,      2
	float knockDetectionWindowEnd;;"angle",      1,      0,       -1000, 1000,      2


	float idleStepperReactionTime;;"ms",      1,      0,       1, 300,      0
	float knockVThreshold;;"V",      1,      0,       1, 5,      2

	
	int idleStepperTotalSteps;;"count",      1,      0,       5, 3000,      0

	float noAccelAfterHardLimitPeriodSecs;TODO: finish this #413;"Seconds",      1,      0,       0, 60,      0

	
	
	
	float tachPulseDuractionMs;;"ms",        1,     0,    0.0,    100.0,  2
	int tachPulseTriggerIndex;+Trigger cycle index at which we start tach pulse (performance consideration);"index",     1,     0,    0.0,    360.0,  0
	
	float wwaeTau;+Length of time the deposited wall fuel takes to dissipate after the start of acceleration. ;"Seconds",        1,     0,    0.0,    3.0,  2
	
	float fuelRailPressure;;     "kPa",    1,      0.0,       0,  1000.0,        2
	float alternator_derivativeFilterLoss;;    "x",    1,      0.0,       -1000000,  1000000,        4
	float alternator_antiwindupFreq;;    "x",    1,      0.0,       -1000000,  1000000,        4
	int16_t tps2Min;Closed throttle#2. todo: extract these two fields into a structure\nSee also tps2_1AdcChannel\nset tps2_min X;"ADC",      1,     0,    0, 1023,      0
	int16_t tps2Max;Full throttle#2. tpsMax value as 10 bit ADC value. Not Voltage!\nSee also tps1_1AdcChannel\nset tps2_max X;"ADC",      1,     0,    0, 1023,      0
	
	
	float mapErrorDetectionTooLow;kPa value which is too low to be true;"kPa",        1,     0,    -100.0,    100.0,  2
	float mapErrorDetectionTooHigh;kPa value which is too high to be true;"kPa",        1,     0,    -100.0,    800.0,  2

	uint16_t multisparkSparkDuration;; "ms", 0.001, 0, 0, 3, 2
	uint16_t multisparkDwell;; "ms", 0.001, 0, 0, 3, 2

	
	float wwaeBeta;+0 = No fuel settling on port walls 1 = All the fuel settling on port walls setting this to 0 disables the wall wetting enrichment. ;"Fraction",        1,     0,    0.0,    1.0,  2
	
	float throttlePedalUpVoltage;;"voltage",      1,     0,    -6,   6,      2
	float throttlePedalWOTVoltage;+Pedal in the floor;"voltage",      1,     0,    -6,   6,      2
	
	int16_t startUpFuelPumpDuration;+on ECU start turn fuel pump on to build fuel pressure;"seconds",        1,     0,  0,    6000,  0
	int16_t idlePidRpmDeadZone;If RPM is close enough let's leave IAC alone, and maybe engage timing PID correction;"",        1,     0,  0,    1000,  0
	
	


	float targetVBatt;+This is the target battery voltage the alternator PID control will attempt to maintain;"Volts",      1,      0,       0,30,      1
	float alternatorOffAboveTps;+Turns off alternator output above specified TPS, enabling this reduced parasitic drag on the engine at full load.;"%",  1,      0,       0, 200,      2
	float startOfCrankingPrimingPulse;+Prime pulse for cold engine, duration in ms\nLinear interpolation between -40F/-40C and fallout temperature\n\nSee also isFasterEngineSpinUpEnabled\nset cranking_priming_pulse X;"ms",        1,     0,    0, 200,     1
	
	int16_t afterCrankingIACtaperDuration;+This is the duration in cycles that the IAC will take to reach its normal idle position, it can be used to hold the idle higher for a few seconds after cranking to improve startup.;"cycles",        1,     0,  0,    5000,  0
	int16_t iacByTpsTaper;+Extra IAC, in percent between 0 and 100, tapered between zero and idle deactivation TPS value;"percent",        1,     0,  0,    500,  0

	int tpsAccelLength;+This is the number of engine cycles that the TPS position change can occur over, a longer duration will make the enrichment more active but too long may affect steady state driving, a good default is 30-60 cycles. ;"Engine Cycles",        1,     0,    1, 200,     0
	float maxDeltaTps;+TPS change in % per engine cycle.;"dTPS",        1,     0,    0, 200,     3
	
	
	int engineLoadAccelLength;;"Engine Cycles",        1,     0,    1, 200,     0
	
	float loadBasedAeMaxEnleanment;;"Engine Cycles",        1,     0,    0, 200,     1
	float engineLoadDecelEnleanmentMultiplier;;"%",        100,     0,    0, 600,     1
	float loadBasedAeMaxEnrich;;"Engine Cycles",        1,     0,    0, 200,     1
	float loadBasedAeMult;;"%",        100,     0,    0, 600,     1

	uint32_t uartConsoleSerialSpeed;;"BPs",      1,      0,       0,1000000,      0
	float maxDeltaTpsEnlean;;"dTps",        1,     0,    0, 200,     1
	float tpsTpsEnleanFactor;;"%",        100,     0,    0, 200,     1
	float slowAdcAlpha;+ExpAverage alpha coefficient;"%",        100,     -1,    0, 600,     1
	
	

	uint32_t auxSerialSpeed;;"BPs",      1,      0,       0,1000000,      0

	float throttlePedalSecondaryUpVoltage;;"voltage",      1,     0,    -6,   6,      2
	float throttlePedalSecondaryWOTVoltage;+Pedal in the floor;"voltage",      1,     0,    -6,   6,      2

	
	can_baudrate_e canBaudRate; set can_baudrate
	uint8_t[3] unused101


	float boostCutPressure;kPa value at which we need to cut fuel and spark, 0 if not enabled;"kPa",        1,     0,    0, 500,     0



	float fixTiming;Fixed timing, useful for TDC testing;"deg",      1,     0,   -720,    720,   2
	float mapLowValueVoltage;MAP voltage for low point;"v",      1,     0,   0.0,    10,   2 
	float mapHighValueVoltage;MAP voltage for low point;"v",      1,     0,   0.0,    10,   2 
	float egoValueShift;EGO value correction;"value",      1,     0,   -10.0,    10,   2 

	int crankingIACposition;+This is the IAC position during cranking, some engines start better if given more air during cranking to improve cylinder filling.;"",      1,     0,   -100.0,    100, 0
	float tChargeMinRpmMinTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMinRpmMaxTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMaxRpmMinTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMaxRpmMaxTps;;"mult",        1,     0,  0,    3,  4   

	


	float[NARROW_BAND_WIDE_BAND_CONVERSION_SIZE] narrowToWideOxygenBins;Narrow Band WBO Approximation;"V",        1,     0,   -10.0,    10.0,  3
	float[NARROW_BAND_WIDE_BAND_CONVERSION_SIZE] narrowToWideOxygen;;"ratio",      1,     0,      -40.0,    40.0,   2
	
	vvt_mode_e vvtMode;set vvt_mode X
	
	
	custom tle8888_mode_e 1 bits, U08, @OFFSET@, [0:7], "Auto", "SemiAuto", "Manual", "Hall"
	
	
	
	

	float autoTuneCltThreshold;
	float autoTuneTpsRocThreshold;
	float autoTuneTpsQuietPeriod;

	float postCrankingFactor;Fuel multiplier taper, see also postCrankingDurationSec;"mult",        1,     0,  0,    100,  4
	float postCrankingDurationSec;See also postCrankingFactor;"seconds",        1,     0,  0,    100,  2
	
	
	cfg_float_t_1f[IGNITION_PIN_COUNT iterate] timing_offset_cylinder;per-cylinder timing correction

	float idlePidActivationTime;;"seconds",        1,     0,  0,    60,  1

	oil_pressure_config_s oilPressure;

	
	int16_t rpmMaxDfco;+This sets the RPM limit above which the fuel cut is deactivated, activating this maintains fuel flow at high RPM to help cool pistons;"rpm",        1,     0,  0,    5000,  0
	int16_t rpmMinDfco;+This sets the RPM limit below which the fuel cut is deactivated, this prevents jerking or issues transitioning to idle;"rpm",        1,     0,  0,    5000,  0
	int16_t tpsTresholdDfco;+percent between 0 and 100 below which the fuel cut is deactivated, this helps low speed drivability.;"%",        1,     0,  0,    100,  1
	int16_t cltTresholdDfco;+Fuel cutoff is deactivated below this coolant threshold.;"C",        1,     0,  -100,    100,  0
	
	int16_t pidExtraForLowRpm;+Increases PID reaction for RPM<target by adding extra percent to PID-error;"%",        1,     0,  0,    100,  0
	int16_t mapTresholdDfco;+MAP value above which fuel injection is re-enabled.;"kPa", 1, 0, 0, 250, 0
	

	float tChargeAirCoefMin;;"Min tCharge Coeff.",        1,     0,  0.0,    1.0,  4
	float tChargeAirCoefMax;;"Max tCharge Coeff.",        1,     0,  0.0,    1.0,  4
	float tChargeAirFlowMax;;"Max Air Flow, kg/h",        1,     0,  0.0,    1000.0,  1
	float tChargeAirIncrLimit;;"tChange Increment Limit, deg/sec",        1,     0,  0.0,    100.0,  1
	float tChargeAirDecrLimit;;"tChange Decrement Limit, deg/sec",        1,     0,  0.0,    100.0,  1

	#define tChargeMode_e_enum "RPM+TPS (Default)", "Air Mass Interpolation"
	custom tChargeMode_e 4 bits,    U32,   @OFFSET@, [0:0], @@tChargeMode_e_enum@@
	tChargeMode_e tChargeMode;
	
	
	
	
	int16_t etb_iTermMin;iTerm min value;"",        1,     0,  -30000,    30000.0,  0
	int16_t etb_iTermMax;iTerm max value;"",        1,     0,  -30000,    30000.0,  0
	float etbDeadband;;"",        1,     0,  0,    100.0,  2
	

	
	int16_t idleTimingPidWorkZone;+When the current RPM is closer than this value to the target, closed-loop idle timing control is enabled.;"RPM",        1,     0,  0,    1000,  0
	int16_t idleTimingPidDeadZone;+If the RPM closer to target than this value, disable timing correction to prevent oscillation;"RPM",        1,     0,  0,    1000,  0
	int16_t idlePidFalloffDeltaRpm;+Taper out idle timing control over this range as the engine leaves idle conditions;"RPM",        1,     0,  0,    1000,  0

	int16_t tpsAccelFractionCycles;+A delay in cycles between fuel-enrich. portions;"Engine Cycles",        1,     0,  0,    500,  0
	float tpsAccelFractionDivisor;+A fraction divisor: 100 or less = entire portion at once, or split into diminishing fractions;"%",        100,     0,  0,    500,  0

	int16_t idlerpmpid_iTermMin;iTerm min value;"",        1,     0,  -30000,    30000.0,  0
	int16_t idlerpmpid_iTermMax;iTerm max value;"",        1,     0,  -30000,    30000.0,  0
	
	float etbIdleThrottleRange; ETB idle authority; "%", 1, 0, 0, 15, 0

	uint8_t triggerCompCenterVolt;+Trigger comparator center point voltage;"V",        @@VOLTAGE_1_BYTE_PACKING_DIV@@,     0,      0.0,   5.1,   2
	uint8_t triggerCompHystMin;+Trigger comparator hysteresis voltage (Min);"V",        @@VOLTAGE_1_BYTE_PACKING_DIV@@,     0,      0.0,   5.1,   2
	uint8_t triggerCompHystMax;+Trigger comparator hysteresis voltage (Max);"V",        @@VOLTAGE_1_BYTE_PACKING_DIV@@,     0,      0.0,   5.1,   2
	uint8_t triggerCompSensorSatRpm;+VR-sensor saturation RPM;"RPM",        @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0

	
	can_vss_nbc_e canVssNbcType;set can_vss X

	gppwm_channel[GPPWM_CHANNELS iterate] gppwm;

	uint16_t mc33_i_boost;;"X",   1,   0.0,        0,  64000,   0
	uint16_t mc33_i_peak;;"X",   1,   0.0,        0,  64000,   0
	
	uint16_t mc33_i_hold;;"X",   1,   0.0,        0,  64000,   0
	uint16_t mc33_t_max_boost;;"X",   1,   0.0,        0,  64000,   0
	
	uint16_t mc33_t_peak_off;;"X",   1,   0.0,        0,  64000,   0
	uint16_t mc33_t_peak_tot;;"X",   1,   0.0,        0,  64000,   0
	
	uint16_t mc33_t_bypass;;"X",   1,   0.0,        0,  64000,   0
	uint16_t mc33_t_hold_off;;"X",   1,   0.0,        0,  64000,   0
	
	uint16_t mc33_t_hold_tot;;"X",   1,   0.0,        0,  64000,   0
	uint16_t unused102

	
float vvtToothMinAngle;;"",        1,     0,  -30000,    30000.0,  0
float vvtToothMaxAngle;;"",        1,     0,  -30000,    30000.0,  0

	float vvtOffset;+Angle between cam sensor and VVT zero position\nset vvt_offset X;"value",      1,      0,       -720, 1000,      1

float[DWELL_CURVE_SIZE] sparkDwellRpmBins;On single-coil or wasted spark setups you have to lower dwell at high RPM;"RPM",     1,   0.0,      0.0,  18000,   2
float[DWELL_CURVE_SIZE] sparkDwellValues;;"ms",	   1,   0.0,      0.0,  30.0,    2
	
tle8888_mode_e tle8888mode;
uint8_t[3] unusedSomethingWasHere;
tle8888filter_e tle8888VrFilter
tle8888detection_voltage_e tle8888VrDetectionVoltage
tle8888vrpeak_time_e tle8888VrPeakTime

trigger_filter_e triggerFilter
	
float syncRatioFrom;;"",        1,     0,  0,    10,  2
float syncRatioTo;;"",        1,     0,  0,    10,  2
float idle_antiwindupFreq;+0.1 is a good default value;    "x",    1,      0.0,       -1000000,  1000000, 1       
float idle_derivativeFilterLoss;+0.1 is a good default value;    "x",    1,      0.0,       -1000000,  1000000, 1        

float stoichRatioPrimary;;"",        1,     0,  0,    20,  1

float knockBandCustom;;"",        1,     0,  0,    30,  1

uint32_t storedLambda;
uint32_t storedHeater;


	int[434] mainUnusedEnd;

! end of engine_configuration_s
end_struct

engine_configuration_s engineConfiguration;



float cj125Pfactor;;"",        	1,     0,  		0,    30,  3
float cj125Ifactor;;"",        	1,     0,  		0,    30,  3


fsio_table_8x8_f32t vvtTable;
!vvt_table_f32t vvtTable;
float[VVT_LOAD_COUNT] vvtLoadBins;;{ bitStringValue(vvtLoadUnits ,  vvt_vvtLoadAxis) }, 1,   0,        0,  600.0,   1
float[VVT_RPM_COUNT] vvtRpmBins;;"RPM",	   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 



	float[CLT_CURVE_SIZE] iacCoastingBins;CLT-based idle position for coasting (used in Auto-PID Idle mode);"C",        1,     0,   -100.0,    250.0,  2
	float[CLT_CURVE_SIZE] iacCoasting;    CLT-based idle position for coasting (used in Auto-PID Idle mode);"%",      1,     0,      0.0,    100.0,   2
	int[24] unused125

	
	iac_pid_mult_t iacPidMultTable;
	uint8_t[IAC_PID_MULT_SIZE] iacPidMultLoadBins;;"Load",   1,   0.0,        0,  500.0,   2
	uint8_t[IAC_PID_MULT_SIZE] iacPidMultRpmBins;;"RPM",        @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0	

float[CRANKING_ADVANCE_CURVE_SIZE] crankingAdvanceBins;+Optional timing advance table for Cranking (see enableCrankingTimingTable);"RPM",      1,     0,   0.0,    18000,   2
float[CRANKING_ADVANCE_CURVE_SIZE] crankingAdvance    ;+Optional timing advance table for Cranking (see enableCrankingTimingTable);"deg",      1,     0,     -20, 90,    2
float[ETB_BIAS_CURVE_LENGTH] etbBiasBins;target TPS value, 0 to 100%\nTODO: use int8 data date once we template interpolation method;"target TPS position",   1,   0.0,        0,  100.0,   1
float[ETB_BIAS_CURVE_LENGTH] etbBiasValues;PWM bias, 0 to 100%;"ETB duty cycle bias",   1,   0.0,        -100,  100.0,   2
float[MAP_ACCEL_TAPER] loadBasedAeDecayBins;;"Engine Cycles",      1,     0,   0.0,    300,   0
float[MAP_ACCEL_TAPER] loadBasedAeDecayMult;;"%",      100,     -1,   0.0,    300,   2
float[CLT_CURVE_SIZE] cltIdleRpmBins;CLT-based target RPM for automatic idle controller;"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CURVE_SIZE] cltIdleRpm;See idleRpmPid;"",      1,     0,      0.0,    8000.0,   0
float[CRANKING_CURVE_SIZE] crankingTpsCoef;Cranking fuel correction coefficient based on TPS;"Ratio",      100,     0,      0.0,    700.0,   0
float[CRANKING_CURVE_SIZE] crankingTpsBins;;"%",        1,     0,    0.0,    100.0,  2

int[16] unused124

float[AFTERSTART_HOLD_CURVE_SIZE] afterstartCoolantBins;;"C",           1,     0, -100.0,  250.0,   0
float[AFTERSTART_HOLD_CURVE_SIZE] afterstartHoldTime;;"Seconds",        1,     0,      0,    100,   1
float[AFTERSTART_ENRICH_CURVE_SIZE] afterstartEnrich;;"%",              100,     -1,      0,    600,   1
float[AFTERSTART_DECAY_CURVE_SIZE] afterstartDecayTime;;"Seconds",      1,     0,      0,    100,   1


boost_table_t boostTableOpenLoop;

uint8_t[BOOST_RPM_COUNT] boostRpmBins;;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 

boost_table_t boostTableClosedLoop;
uint8_t[BOOST_LOAD_COUNT] boostTpsBins;;"%",   @@TPS_1_BYTE_PACKING_MULT@@,   0.0,        0,  100.0,   2

pedal_to_tps_t pedalToTpsTable;
uint8_t[PEDAL_TO_TPS_SIZE] pedalToTpsPedalBins;;"%",           1,     0,      0.0,   120.0,   0

uint8_t[PEDAL_TO_TPS_SIZE] pedalToTpsRpmBins;;"RPM",        @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0

float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorrBins;CLT-based cranking position multiplier for simple manual idle controller;"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorr    ;CLT-based cranking position multiplier for simple manual idle controller;"%",      100,     0,      0.0,    500.0,   0

float[IDLE_ADVANCE_CURVE_SIZE] idleAdvanceBins;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"RPM",      1,     0,   0.0,    18000,   2
float[IDLE_ADVANCE_CURVE_SIZE] idleAdvance    ;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"deg",      1,     0,     -20, 90,    2
float[IDLE_VE_CURVE_SIZE] idleVeBins;Optional VE table for Idle (see useSeparateVEForIdle);"RPM",      1,     0,   0.0,    18000,   2
float[IDLE_VE_CURVE_SIZE] idleVe;    Optional VE table for Idle (see useSeparateVEForIdle);,"%", 1, 0, 0, 999.0, 2

float[CLT_CURVE_SIZE] cltFuelCorrBins;;"C",        1,     0,   -100.0,    250.0,  0
float[CLT_CURVE_SIZE] cltFuelCorr;;"% Trim",      100,     -1,      -100,    500,   1

float[IAT_CURVE_SIZE] iatFuelCorrBins;;"C",        1,     0,   -100.0,    250.0,   0
float[IAT_CURVE_SIZE] iatFuelCorr;;"% Trim",      100,     -1,      -100,    400,   1

float[CRANKING_CURVE_SIZE] crankingFuelCoef;;"%",      100,     -1,      -100,    400,   1
float[CRANKING_CURVE_SIZE] crankingFuelBins;;"C",        1,     0,    -80.0,    170.0,  0

float[CRANKING_CURVE_SIZE] crankingCycleCoef;;"%",      100,     -1,      -100,    400,   1
float[CRANKING_CURVE_SIZE] crankingCycleBins;;"counter",        1,     0,    -80.0,    170.0,  0

float[CLT_CURVE_SIZE] cltIdleCorrBins;CLT-based idle position multiplier for simple manual idle controller;"C",        1,     0,   -100.0,    250.0,  1
float[CLT_CURVE_SIZE] cltIdleCorr;    CLT-based idle position multiplier for simple manual idle controller;"percent",      100,     0,      0.0,   400,   0

angle_table_t ignitionIatCorrTable;
float[IGN_LOAD_COUNT] ignitionIatCorrLoadBins;;"Temperature",   1,   0.0,        0,  500.0,   1
float[IGN_RPM_COUNT] ignitionIatCorrRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 1

angle_table_t injectionPhase;
float[FUEL_LOAD_COUNT] injPhaseLoadBins;;"Load",   1,   0.0,        0,  500.0,   2
float[FUEL_RPM_COUNT] injPhaseRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

ignition_table_t advanceTable;
float[IGN_LOAD_COUNT] smap_table;;{ bitStringValue(algorithmUnits ,  fuelAlgorithm) },   1,   0.0,        0,  500.0,   1
float[IGN_RPM_COUNT] srpm_table;;"RPM",	   1,   0.0,        0,  18000.0, 2

ve_table_t veTable;
float[FUEL_LOAD_COUNT] fmap_table;;{ bitStringValue(algorithmUnits ,  fuelAlgorithm) },	1,   0.0,        0,  400.0,   1
float[FUEL_RPM_COUNT] frpm_table;;"RPM",	   1,   0.0,        0,  18000.0, 2

afr_table_t afrTable;		
float[FUEL_LOAD_COUNT] afrLoadBins;;"",	1,   0.0,        0,  500.0,   2
float[FUEL_RPM_COUNT] afrRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

! ve_table_t ve2Table;
! float[FUEL_LOAD_COUNT] ve2LoadBins;;"kPa",	1,   0.0,        0,  500.0,   2
! float[FUEL_RPM_COUNT] ve2RpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

tps_tps_table_t tpsTpsAccelTable;
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelFromRpmBins;;"From TPS",	   1,      0,      0.0,  30000.0,   2
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelToRpmBins;;"To TPS",	   1,      0,      0.0,  25500.0,   2

end_struct



! Live Documentation Structure
#define LDS_SPEED_DENSITY_STATE_INDEX 2
#define LDS_ENGINE_STATE_INDEX 3
#define LDS_FUEL_TRIM_STATE_INDEX 4
#define LDS_TPS_TPS_ENEICHMENT_STATE_INDEX 5
#define LDS_TRIGGER_CENTRAL_STATE_INDEX 6
#define LDS_ETB_PID_STATE_INDEX 7
#define LDS_IDLE_PID_STATE_INDEX 8
#define LDS_ALTERNATOR_PID_STATE_INDEX 9
#define LDS_CJ125_PID_STATE_INDEX 10
#define LDS_TRIGGER_STATE_STATE_INDEX 11



#define GAUGE_NAME_VERSION "firmware"
#define GAUGE_NAME_TRG_ERR "trg err"
#define GAUGE_NAME_VVT "VVT position"
#define GAUGE_NAME_TIMING_ADVANCE "timing"
#define GAUGE_NAME_VVS "Vehicle Speed"
#define GAUGE_NAME_VBAT "VBatt"
#define GAUGE_NAME_TIME "Time"
#define GAUGE_NAME_RPM "RPM"
#define GAUGE_NAME_CLT "CLT"
#define GAUGE_NAME_IAT "IAT"
#define GAUGE_NAME_TPS "TPS"
#define GAUGE_NAME_TPS2 "TPS2"
#define GAUGE_NAME_MAP "MAP"
#define GAUGE_NAME_MAF "MAF"
#define GAUGE_NAME_ENGINE_LOAD "Engine Load"
#define GAUGE_NAME_CPU_TEMP "CPU Temperature"
#define GAUGE_NAME_ETB_TARGET "ETB position target"
#define GAUGE_NAME_ETB_ERROR "ETB position error"
#define GAUGE_NAME_ETB_DUTY "ETB duty cycle"

#define GAUGE_NAME_ACCEL_X "Acceleration: X"
#define GAUGE_NAME_ACCEL_Y "Acceleration: Y"
#define GAUGE_NAME_ACCEL_Z "Acceleration: Z"

#define GAUGE_NAME_BARO_PRESSURE "Barometric pressure"

#define GAUGE_NAME_ECU_TEMPERATURE "ECU temperature"


#define INDICATOR_NAME_CLUTCH_UP "clutch: up"
#define INDICATOR_NAME_CLUTCH_DOWN "clutch: down"
#define INDICATOR_NAME_BRAKE_DOWN "brake: down"
#define INDICATOR_NAME_AC_SWITCH "AC switch"

#define GAUGE_NAME_AIR_FLOW "MAF air flow"
#define GAUGE_NAME_AIR_MASS "air mass"

#define GAUGE_NAME_WARNING_LAST "warning: last"
#define GAUGE_NAME_WARNING_COUNTER "warning: counter"


#define GAUGE_NAME_KNOCK_LEVEL "knock: current level"
#define GAUGE_NAME_KNOCK_COUNTER "knock: counter"


#define GAUGE_NAME_FUEL_BARO_CORR "fuel: Barometric pressure correction"
#define GAUGE_NAME_THROTTLE_PEDAL "Throttle pedal position"
#define GAUGE_NAME_INJECTOR_LAG "fuel: injector lag"
#define GAUGE_NAME_FUEL_TPS_ROC "fuel: TPS change"
#define GAUGE_NAME_FUEL_CHARGE_TEMP "fuel: Estimated charge temperature"
#define GAUGE_NAME_FUEL_TPS_EXTRA "fuel: TPS acceleration extra fuel ms"
#define GAUGE_NAME_FUEL_EL_EXTRA "fuel: engine load acceleration extra fuel"
#define GAUGE_NAME_FUEL_CLT_CORR "fuel: CLT correction"
#define GAUGE_NAME_FUEL_IAT_CORR "fuel: IAT correction"
#define GAUGE_NAME_FUEL_VE "fuel: VE"
#define GAUGE_NAME_FUEL_CRANKING "fuel: cranking"
#define GAUGE_NAME_FUEL_RUNNING "fuel: running"
#define GAUGE_NAME_FUEL_LAST_INJECTION  "fuel: Last injection"
#define GAUGE_NAME_FUEL_BASE "fuel: base"
#define GAUGE_NAME_FUEL_PID_CORR "fuel: Short-term fuel trim"
#define GAUGE_NAME_FUEL_WALL_AMOUNT "fuel: wall amount"
#define GAUGE_NAME_FUEL_WALL_CORRECTION "fuel: wall corr ms"
#define GAUGE_NAME_FUEL_LOAD "fuel: load"

#define GAUGE_NAME_FUEL_INJ_DUTY "fuel: injector duty cycle"
#define GAUGE_NAME_TCHARGE "fuel: SD tCharge"
#define GAUGE_NAME_TARGET_AFR "fuel: target AFR"
#define GAUGE_NAME_AFR "Air/Fuel Ratio"
#define GAUGE_NAME_IAC "Idle Air Valve"

#define GAUGE_NAME_DWELL_DUTY "dwell: coil duty cycle"
#define GAUGE_COIL_DWELL_TIME "dwell: coil charge time"
#define GAUGE_NAME_IGNITION_LOAD "ign: load"

#define GAUGE_NAME_DEBUG_F1 "debug f1"
#define GAUGE_NAME_DEBUG_F2 "debug f2: iTerm"
#define GAUGE_NAME_DEBUG_F3 "debug f3: prevError"
#define GAUGE_NAME_DEBUG_F4 "debug f4: iParam"
#define GAUGE_NAME_DEBUG_F5 "debug f5: dParam"
#define GAUGE_NAME_DEBUG_F6 "debug f6: dTerm"
#define GAUGE_NAME_DEBUG_F7 "debug f7"

#define GAUGE_NAME_DEBUG_I1 "debug i1: pParam"
#define GAUGE_NAME_DEBUG_I2 "debug i2: offset"
#define GAUGE_NAME_DEBUG_I3 "debug i3"
#define GAUGE_NAME_DEBUG_I4 "debug i4"
#define GAUGE_NAME_DEBUG_I5 "debug i5"


#define PROTOCOL_OUTPIN "outpin"
#define PROTOCOL_ANALOG_CHART "analog_chart"
#define PROTOCOL_ENGINE_SNIFFER "wave_chart"
#define PROTOCOL_VERSION_TAG "rusEfiVersion"
#define PROTOCOL_TEST_RESPONSE_TAG "ts_p_alive"

! Engine Sniffer Protocol
#define PROTOCOL_ES_DOWN "d"
#define PROTOCOL_ES_UP "u"
#define TOP_DEAD_CENTER_MESSAGE "r"

! Engine Sniffer channel names
#define PROTOCOL_CRANK1 "t1"
#define PROTOCOL_CRANK2 "t2"
#define PROTOCOL_CRANK3 "t3"

#define PROTOCOL_VVT_NAME "VVT"
#define PROTOCOL_HIP_NAME "HIP"
#define PROTOCOL_TACH_NAME "tach"
#define PROTOCOL_DIZZY_NAME "dizzy"

#define PROTOCOL_WA_CHANNEL_1 "input1"
#define PROTOCOL_WA_CHANNEL_2 "input2"
#define PROTOCOL_WA_CHANNEL_3 "input3"
#define PROTOCOL_WA_CHANNEL_4 "input4"



#define PROTOCOL_COIL1_SHORT_NAME "c1"
#define PROTOCOL_INJ1_SHORT_NAME "i1"



! some board files override this value using prepend file
#define ts_show_hip9011 true
#define ts_show_main_relay true
#define ts_show_main_relay_microRusEFI_message false
#define ts_show_cj125 true
#define ts_show_etb true
#define ts_show_etb_pins true
#define ts_show_full_pinout true
#define ts_show_lcd true
#define ts_show_joystick true
#define ts_show_egt true
#define ts_show_gps true
#define ts_show_analog_divider true
#define ts_show_spi true
#define ts_show_sd_card true
#define ts_show_can_pins true
#define ts_show_tunerstudio_port true
#define ts_show_trigger_comparator false
#define ts_show_auxserial_pins true

#define show_test_presets true
#define show_Frankenso_presets true
#define show_microRusEFI_presets true
#define show_Proteus_presets true